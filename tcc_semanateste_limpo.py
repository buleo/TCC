# -*- coding: utf-8 -*-
"""TCC-Gaudium-SemanaTeste - Limpo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a7im8bkWPgHU5a-xDs3SjH6KtBKl3Zz5

# **Inicialização**
"""

#para conectar ao Drive
from google.colab import drive # Carrega biblioteca para montar e carregar drive
drive.mount('/content/drive') # Esse código pedirá autenticação

import os
os.chdir("/content/drive/My Drive/TCC")

!ls
#https://colab.research.google.com/drive/1MPBU7kXUIbZcyR8jMJgobImvmQ5TGWAA

"""### **Importacao de bibliotecas**"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

"""#**Carga da Base e Seleção da Cidade de Partida**"""

#Retirar do Comentário a Cidade de Partida
#cidade_partida = 'Patos de Minas'
cidade_partida = 'Fortaleza'
#cidade_partida = 'Santarem'
#cidade_partida = 'Petrolina'

if (cidade_partida == 'Fortaleza'):
  df1 = pd.read_csv('Corridas_Fortaleza-FINAL-Acentuado-Probabilidades-ComSemanaTeste.csv', decimal=',', delimiter=';') 
else:
  df1 = pd.read_csv('Corridas_Cidades_Eleitas-FINAL-Acentuado-Probabilidades-ComSemanaTeste.csv', decimal=',', delimiter=';') 


df1=df1[df1['nome_cidade_partida'] == cidade_partida]


### TESTANDO SÓ PERÌODO DO HORÀRIO COMERCIAL
# Se for rodar simulação somente para um período do dia, descomentar a linha abaixo
df1 = df1[(df1['hora_da_criacao'] >= 8) & (df1['hora_da_criacao'] <= 19)]

# colocar id como nome de linha
df1 = df1.set_index('id')
df1.head(1000)

#dimensões da base
df1.shape

### MULTIPLICA POR 100 A PROBABILIDADE PARA DIMINUIR PROBLEMAS DE CÁLCULOS COM VALORES PEQUENOS
df1['PROBABILIDADE'] = df1['PROBABILIDADE']*100
df1['PROBABILIDADE'].head()

"""# **Converte Variáveis para DUMMY**

### **Converte Variáveis Numéricas para String**
"""

# Essa conversão é necessária para permitir que no passo seguinte sejam convertidas para DUMMY
# Foram convertidas para DUMMY pois são categóricas
df1['dia_semana_da_criacao']=df1['dia_semana_da_criacao'].astype(str)
df1['dia_da_criacao']=df1['dia_da_criacao'].astype(str)
df1['hora_da_criacao']=df1['hora_da_criacao'].astype(str)

"""### **Conversão para DUMMY**"""

df1 = pd.get_dummies(df1)  
df1.head()

"""# **Separa em Base de Treino e Base de Teste**

### **Separa a Semana de Teste**
"""

# Criei uma semana de teste na base de entrada com todas as combinações 
# possíveis de bairros, dia da semana e horário para extrair as estimativas
# do modelo para essa semana
# A semana corresponde ao mesmo período da Base de Teste, ou seja,
# 12 a 18 de Janeiro

#SEPARA A SEMANA DE TESTE
if cidade_partida == 'Petrolina':
  df_semana_teste = df1.loc[200000:299999] #PETROLINA
  df1.loc[200000:299999]
  df1 = df1.loc[:199999]
elif cidade_partida == 'Patos de Minas':
  df_semana_teste = df1.loc[100000:199999] #Patos de MINAS
  df1.loc[100000:199999]
  df1 = df1.loc[:99999]
elif cidade_partida == 'Fortaleza':
  df_semana_teste = df1.loc[300000:399999] #Fortaleza
  df1.loc[300000:399999]
  df1 = df1.loc[:299999]

# EXCLUI A COLUNA PROBABILIDADE (TODA ZERADA) DA SEMANA DE TESTE
# Não precisamos dessa informação pois essa será a variável a ser prevista
# pelo modelo
df_semana_teste.head()
df_semana_teste=df_semana_teste.drop(columns=['PROBABILIDADE'])
df_semana_teste.head()

"""### **Criação de Base de Teste "Aleatória"**

#### **Indicar a semente inicial e para divisão da base em treino e teste**
"""

## NÂO usei essa solução no treino do MODELO
## Usei a opção seguinte de base de teste direcionada para o período de 
## 12 a 18 de Janeiro
import random
np.random.seed(0) #semente inicial
nlinhas = df1.shape[0]
nlinhas

from sklearn.model_selection import train_test_split
#Divide a base em treino e teste. A coluna 'PROBABILIDADE' é o Label. Test_size diz o tamanho da amostra de Teste (no caso 30%) 
#x_train, x_test, y_train, y_test = train_test_split(df1.drop(columns=['PROBABILIDADE']), 
#                                                    df1['PROBABILIDADE'], test_size=0.3)
#x_train.head()

"""### **Criação de Base de Teste "Direcionada" (Semana de 12 a 18 / Janeiro)**"""

## VERSÂO DIRECIONADA PARA TREINAR COM MÊS TODO EXCETO SEMANA DE TESTE

x_test = df1[(df1['dia_da_criacao_12'] == 1)|(df1['dia_da_criacao_13'] == 1)|(df1['dia_da_criacao_14'] == 1)|(df1['dia_da_criacao_15'] == 1)|(df1['dia_da_criacao_16'] == 1)|(df1['dia_da_criacao_17'] == 1)|(df1['dia_da_criacao_18'] == 1)]
y_test = x_test['PROBABILIDADE']
x_test = x_test.drop(columns=['PROBABILIDADE'])

x_train = df1[(df1['dia_da_criacao_12'] == 0)&(df1['dia_da_criacao_13'] == 0)&(df1['dia_da_criacao_14'] == 0)&(df1['dia_da_criacao_15'] == 0)&(df1['dia_da_criacao_16'] == 0)&(df1['dia_da_criacao_17'] == 0)&(df1['dia_da_criacao_18'] == 0)]
y_train = x_train['PROBABILIDADE']
x_train = x_train.drop(columns=['PROBABILIDADE'])
x_train
y_train

"""# **Rede Neural**

### **Converte Dataframe de Pandas para Numpy para inserir na RN**
"""

## Conversão necessária para inserir dados nas funções da RN
X_train_normalized = x_train.to_numpy()
X_test_normalized = x_test.to_numpy()
df_semana_teste_normalized = df_semana_teste.to_numpy()

"""### **Importa bibliotecas necessárias para uso na RN**"""

import tensorflow as tf
from keras import Model, Sequential
from keras.layers import Dense
from keras.optimizers import SGD, RMSprop, Adam, Adamax, Adagrad, Adadelta, Nadam

X_train_normalized.shape[1:]

"""### **Cria a Rede Neural**"""

#Inicia a rede
RN = Sequential()
# Cria primeira camada  e 'input_shape' entradas
RN.add(Dense(314,input_shape = X_train_normalized.shape[1:], activation = 'relu')) # antes sigmoid
#RN.add(Dropout(0.2))


RN.add(Dense(157,activation = 'relu'))
#RN.add(Dense(40,activation = 'relu'))
#RN.add(Dense(22,activation = 'relu'))
#RN.add(Dense(50,activation = 'sigmoid'))
#RN.add(dropout(0.2))
#RN.add(Dense(4,activation = 'sigmoid'))
RN.add(Dense(1,activation = 'relu'))
# linha do programa original --> Cria segunda e última camada 2 células (número de classes)
# RN.add(Dense(NumberOfClasses,activation = 'sigmoid'))

# Diferença Sigmoidal X Softmax
# https://www.google.com/search?q=sigmoid+vs+softmax&oq=sigmoid&aqs=chrome.3.69i57j35i39j0l6.8339j0j7&sourceid=chrome&ie=UTF-8

RN.summary()

"""### **Treina a Rede Neural**"""

# treinamento

#Otimização por Gradiente Descendente (SGD)
#otimizador = SGD(lr=0.001, decay=1e-6, momentum=0.9) #decay=1e-6,
#otimizador = RMSprop()
#otimizador = SGD()
#otimizador = Adam()
otimizador = Nadam()

#Configura o modelo para treinamento
#RN.compile(optimizer = sgd, loss = 'mean_squared_error', metrics = ['accuracy', 'mean_squared_error'])
RN.compile(optimizer = otimizador, loss = 'mean_absolute_percentage_error', #tf.keras.losses.MeanAbsolutePercentageError(), #tf.keras.losses.MeanAbsoluteError(), #tf.keras.losses.MeanSquaredError(), 
           metrics = ['mean_absolute_error',  #tf.keras.metrics.RootMeanSquaredError(), 
                      'mean_squared_error', 'mean_absolute_percentage_error','accuracy' ])


# Treina o modelo para um certo numero de epocas
trainedRN = RN.fit(X_train_normalized,y_train, epochs = 350, verbose = 0)

"""# **Métricas de Avaliação**

### **Métricas Calculadas Automaticamente pelo Keras**
"""

trainedRN.model.metrics_names

import math
score = trainedRN.model.evaluate(X_test_normalized, y_test, verbose = 0)
print('Test score (loss):', score[0])
print('Test MAE:', score[1])
print('Test RMSE:', math.sqrt(score[2]))
print('Test MSE:', score[2])
print('MAPE:', score[3])
print('Test Accuracy:', score[4])

"""### **Métricas Calculadas por mim para Validação do Resultado do Keras**"""

# Previsão
y_test_predicted = RN.predict(X_test_normalized)

#import math
from sklearn.metrics import mean_squared_error
rmse = math.sqrt(mean_squared_error(y_test, y_test_predicted))
mse = mean_squared_error(y_test, y_test_predicted)
mape = np.mean(np.abs((y_test.to_numpy() - y_test_predicted.transpose())/y_test.to_numpy())) * 100
mae = np.mean(np.abs((y_test.to_numpy() - y_test_predicted.transpose())))

print('MAE: ',mae)
print('RMSE: ', rmse)
print('MSE: ',mse)
print('MAPE: ',mape)

"""# **Apresentação Gráfica da Distância entre Probabilidade Real e Estimada**"""

plt.figure(figsize=(16, 8))
plt.vlines(y_test.index, y_test_predicted,y_test.values, color='red', linewidth=2)

plt.title('Previsão de Regressão')
plt.xlabel('id da Amostra')
plt.ylabel('Distância Real x Previsto')
plt.legend()
plt.savefig('predictions_training_test.pdf',format = 'pdf')
plt.show()

"""# **Faz a previsão da Semana de Testes e Grava resultados para Análise**"""

y_semana_test = RN.predict(df_semana_teste_normalized)
df_semana_teste.insert(loc=df_semana_teste.shape[1], column='PROBABILIDADE', value=y_semana_test, allow_duplicates= True)
df_semana_teste.shape[1]
df_semana_teste.head()
df_semana_teste.to_csv(path_or_buf = 'Resultados_Semana_Teste.csv', sep=';', decimal = ',') #decimal=',',
